<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="Microsoft Word 97/98">
<TITLE>La Saga du LSE et de sa famille (LSD/LSG/LST)</TITLE>
</HEAD>
<BODY>

<B><FONT FACE="Times" SIZE=4><P ALIGN="CENTER">&nbsp;</P>
<P ALIGN="CENTER">La Saga du LSE et de sa famille (LSD/LSG/LST)</P>
<P ALIGN="CENTER">Yves NOYELLE</P>
</B></FONT><FONT FACE="Times"><P ALIGN="CENTER">Service Informatique, &Eacute;cole Sup&eacute;rieure d'&Eacute;lectricit&eacute;, Plateau de Moulon, 91192 GIF/YVETTE CEDEX,<BR>Tel: 33-1-69-41-80-40</P>
<P ALIGN="JUSTIFY">Les LSx (LSD, LSE, LSG, LST) sont des langages de programmation d&eacute;velopp&eacute;s durant les ann&eacute;es 1968-1976 &agrave; l'&Eacute;cole Sup&eacute;rieure d'&Eacute;lectricit&eacute;, dans le but de mettre l'ordinateur au service du programmeur. La philosophie qui a guid&eacute; leur conception est qu'un outil doit faciliter au maximum la vie de celui qui l'emploie et non lui imposer des contraintes, surtout si celles-ci sont &eacute;vitables facilement.</P>
<P ALIGN="JUSTIFY">Cette philosophie gagne du terrain actuellement, mais &agrave; l'&eacute;poque o&ugrave; fut con&ccedil;u LSD (1968), elle n'&eacute;tait pas tr&egrave;s courante. Elle est n&eacute;e de l'exasp&eacute;ration du n&eacute;ophyte que j'&eacute;tais devant les complexit&eacute;s (apparemment) inutiles de la majorit&eacute; des langages et syst&egrave;mes de l'&eacute;poque, et aussi du contact avec le langage PAF (Programmation Automatique de Formules) de la CAB 500, qui au contraire s'efforcait d&eacute;j&agrave; (avant 1960&nbsp;!) de mettre en &#156;uvre une philosophie similaire.</P>
<B><P ALIGN="JUSTIFY">Environnement historique</P>
</B><P ALIGN="JUSTIFY">Fin 1967 se posait le probl&egrave;me suivant au Service Informatique de l'&Eacute;cole Sup&eacute;rieure d'&Eacute;lectricit&eacute; : il fallait donner aux &eacute;l&egrave;ves (environ 600 &agrave; l'&eacute;poque)
acc&egrave;s &agrave; "l'informatique", c'est-&agrave;-dire en pratique &agrave; un ordinateur. Le service avait depuis longtemps (1962) une "calculatrice" SEA CAB 500, mais son usage &eacute;tait r&eacute;serv&eacute; aux quelques privil&eacute;gi&eacute;s qui avaient choisi la section Calcul Automatique, et sa puissance de toute fa&ccedil;on tr&egrave;s limit&eacute;e. Pour r&eacute;soudre ce probl&egrave;me des cr&eacute;dits avaient permis d'acheter un ordinateur IBM 1130, dont la puissance de calcul semblait suffisante pour le mettre &agrave; la disposition de tout le monde.</P>
<P ALIGN="JUSTIFY">Malheureusement, le syst&egrave;me d'exploitation n'&eacute;tait pas &agrave; la hauteur : il n&eacute;cessitait un personnel qualifi&eacute; non n&eacute;gligeable ("perfo-v&eacute;rifs", op&eacute;rateur, assistants pour aider &agrave; la programmation et &agrave; la mise au point), et ne rendait pas pour autant un service extraordinaire ; en particulier, le temps de service &eacute;tait long, l'imprimante &agrave; 80 lignes/minute n'am&eacute;liorant pas les choses...</P>
<P ALIGN="JUSTIFY">Il avait donc &eacute;t&eacute; d&eacute;cid&eacute; de r&eacute;aliser un syst&egrave;me en temps partag&eacute;, au moins pour &eacute;viter les perfo-v&eacute;rifs et l'op&eacute;rateur, et un Hewlett-Packard 2116A (un des premiers mini-ordinateurs, bien adapt&eacute; &agrave; la gestion de p&eacute;riph&eacute;riques) &eacute;tait venu rejoindre le 1130. Mais le langage pr&eacute;vu restait FORTRAN, dont &eacute;videmment le 1130 fournissait un compilateur et le support d'ex&eacute;cution.</P>
<P ALIGN="JUSTIFY">Or, il se trouve qu'&agrave; l'&eacute;poque je revenais de l'universit&eacute; de Stanford (Etats-Unis), un dipl&ocirc;me en poche mais surtout plein d'id&eacute;es en t&ecirc;te, id&eacute;es enrichies par de nombreux contacts avec les gens de l'&eacute;quipe de Patrick Suppes qui avaient r&eacute;alis&eacute;, &agrave; des fins d'enseignement assist&eacute; par ordinateur (d&eacute;j&agrave;&nbsp;!), un syst&egrave;me en temps partag&eacute; convivial sur une petite machine (PDP-1). 
Et donc on me chargea de ce projet.</P>
<P ALIGN="JUSTIFY">En y r&eacute;fl&eacute;chissant, je me suis vite aper&ccedil;u que l'optique temps partag&eacute; influait sur le choix du langage : vu la faible puissance (malgr&eacute; tout) des ordinateurs dont nous disposions, il &eacute;tait notamment souhaitable que ce langage soit compilable ligne &agrave; ligne, pour ne pas avoir &agrave; reprendre toute la traduction d'un programme &agrave; chaque modification (et celles-ci sont nombreuses chez un d&eacute;butant&#133;).</P>
<P ALIGN="JUSTIFY">D'autre part, FORTRAN n'est pas un mod&egrave;le de langage permettant une d&eacute;tection ais&eacute;e des erreurs &agrave; l'ex&eacute;cution, et celles-ci sur la 1130 se traduisaient souvent par la mort du syst&egrave;me ; or nous voulions un syst&egrave;me fiable, et nous cherchions &eacute;galement &agrave; nous passer d'assistants pour la mise au point. Ceci conduisait directement &agrave; un syst&egrave;me interpr&eacute;t&eacute;, dans lequel la d&eacute;tection compl&egrave;te
 d'erreurs s&eacute;mantiques est beaucoup plus facile que dans un syst&egrave;me compil&eacute;, et qui permet de r&eacute;aliser toute protection n&eacute;cessaire pour assurer la fiabilit&eacute;.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">Il restait encore trois objectifs :</P><DIR>
<P ALIGN="JUSTIFY">-&#9;obtenir un syst&egrave;me vraiment utilisable, c'est-&agrave;-dire avec des temps de r&eacute;ponse corrects et des tailles de programme permettant de traiter des probl&egrave;mes r&eacute;els,</P>
<P ALIGN="JUSTIFY">-&#9;faire l'&eacute;conomie du cours de programmation ; le langage d&eacute;fini devait donc &ecirc;tre suffisamment "naturel" pour permettre l'auto-apprentissage, mais sans donner de mauvaises habitudes,</P>
<P ALIGN="JUSTIFY">-&#9;faire en sorte que le produit obtenu soit facile d'emploi et heurte le moins possible le bon sens de l'utilisateur (application de la philosophie pr&eacute;sent&eacute;e plus haut) ; d'autre part, comme l'erreur est humaine, il fallait &eacute;galement que ce produit r&eacute;siste &agrave; n'importe quelle fausse manipulation.</P></DIR>
<B><P ALIGN="JUSTIFY">LSD</P>
</B><P ALIGN="JUSTIFY">Toutes ces contraintes ont men&eacute; entre Mars 1968 et Mars 1969 &agrave; la conception de LSD (Langage Symbolique  Didactique, selon son appellation officielle), et &agrave; sa r&eacute;alisation sur le couple 1130 (16 ko de m&eacute;moire, disque amovible de 1Mo), 2116 (16 Ko de m&eacute;moire, 13 terminaux T&eacute;l&eacute;types ASR33), reli&eacute;s via leur acc&egrave;s direct m&eacute;moire.</P>
<P ALIGN="JUSTIFY">Pour la petite histoire, le nom LSD est en r&eacute;alit&eacute; le second nom du langage, le premier &eacute;tant LPS, pour Langage de Programmation Scientifique, nom s&eacute;rieux s'il en fut, mais dont il s'av&eacute;ra assez vite qu'il &eacute;tait d&eacute;j&agrave; utilis&eacute;. Un fac&eacute;tieux de l'&eacute;quipe, Paul Gavarini, a alors propos&eacute; LSD, en apportant, &agrave; l'appui de sa proposition, un lot de cartes postales "LSD, j'aime", que nous nous empress&acirc;mes de coller sur les ordinateurs. Il restait &agrave; trouver une signification pour cet acronyme ; le premier fut Langage Symbolique Didactique, alors que Langage Sans Difficult&eacute;, tellement mieux adapt&eacute;, ne vint que plus tard.</P>
<P ALIGN="JUSTIFY">LSD satisfaisait les objectifs assign&eacute;s :</P><DIR>
<P ALIGN="JUSTIFY">-&#9;langage compilable ligne &agrave; ligne, dont n'importe quelle ligne, m&ecirc;me une ligne de d&eacute;claration, pouvait &ecirc;tre ajout&eacute;e, modifi&eacute;e, ou supprim&eacute;e, sans recompilation du reste,</P>
<P ALIGN="JUSTIFY">-&#9;identificateurs multilettres pour permettre une bonne lisibilit&eacute; des programmes ; &agrave; vrai dire, les sp&eacute;cifications initiales du langage pr&eacute;voyaient uniquement des identificateurs monolettres, ceci permettant de se passer de table de symboles ; mais la r&eacute;alisation ayant montr&eacute; qu'il restait de l'espace m&eacute;moire disponible dans la 2116, des tables de symboles furent introduites,</P>
<P ALIGN="JUSTIFY">-&#9;proc&eacute;dures fonctions et sous-programmes, avec objets locaux pour permettre une structuration des programmes ; modes de passage de param&egrave;tres par valeur et par adresse (pour &eacute;viter les probl&egrave;mes de FORTRAN avec le passage par adresse seul ; le passage par valeur venait d'ALGOL) ; r&eacute;cursion possible (&agrave; vrai dire parce qu'elle arrivait tout naturellement avec le mode de r&eacute;alisation choisi pour l'interpr&eacute;teur) ; appel des proc&eacute;dures facilement rep&eacute;rable dans le texte source (caract&egrave;re '&amp;' en t&ecirc;te de nom de proc&eacute;dure),</P>
<P ALIGN="JUSTIFY">-&#9;un seul type de donn&eacute;es : le type r&eacute;el, le langage &eacute;tant pr&eacute;vu pour satisfaire les besoins suppos&eacute;s des &eacute;l&egrave;ves-ing&eacute;nieurs de l'&eacute;cole et de leurs enseignants, donc uniquement num&eacute;riques. L'optique du langage &eacute;tant d'&ecirc;tre naturel &agrave; utiliser (par un non-informaticien), je ne voyais pas l'int&eacute;r&ecirc;t de demander au programmeur s'il voulait utiliser des entiers ou des r&eacute;els. Plus 
g&eacute;n&eacute;ralement, je voulais le moins de contraintes possible, en particulier pas de d&eacute;clarations, sauf quand elles sont manifestement n&eacute;cessaires (objets compos&eacute;s), ou quand elles peuvent aider &agrave; la modularit&eacute;
 (variables locales dans les proc&eacute;dures). En fait, la n&eacute;cessit&eacute; d'un autre type, le type caract&egrave;re, est tr&egrave;s vite apparue, et donc il fut rapidement ajout&eacute;,</P>
<P ALIGN="JUSTIFY">-&#9;un seul genre d'objets compos&eacute;s : le tableau (&agrave; une ou deux dimensions). L'approche "facilit&eacute; d'emploi" rendait imp&eacute;ratif que la d&eacute;claration en soit dynamique, car cela para&icirc;t normal &agrave;
 l'utilisateur (au moins d&eacute;butant). De plus, cela permet de moduler au mieux l'encombrement m&eacute;moire d'une t&acirc;che, dont d&eacute;pendent les performances d'un syst&egrave;me avec "swap" (voir ci-apr&egrave;s). La r&eacute;alisation ne
m'en paraissait pas impossible puisque les compilateurs ALGOL y arrivaient&#133;,</P>
<P ALIGN="JUSTIFY">-&#9;instructions conditionnelle et de branchement (je ne voyais pas bien &agrave; l'&eacute;poque l'int&eacute;r&ecirc;t de l'instruction de boucle, qui pouvait parfaitement &ecirc;tre simul&eacute;e par une instruction de branchement,
 et aurait pris un peu de pr&eacute;cieux espace dans le compilateur et l'interpr&eacute;teur) ; &eacute;galement instruction compos&eacute;e, pour augmenter la puissance des instructions conditionnelles (qui devaient n&eacute;anmoins tenir sur une ligne 
de t&eacute;l&eacute;type, c'est-&agrave;-dire 72 caract&egrave;res seulement),</P>
<P ALIGN="JUSTIFY">-&#9;instructions de lecture et d'&eacute;criture cherchant &agrave; faciliter la vie de l'utilisateur ; en particulier, pour l'instruction de lecture, redemande automatique d'un autre nombre si la syntaxe du pr&eacute;c&eacute;dent &eacute;tait
incorrecte, et d&eacute;sactivation du clavier (sauf en ce qui concerne la touche d'interruption, voir plus loin) quand le programme n'&eacute;tait pas en lecture ; pour l'instruction d'&eacute;criture, sortie non tronqu&eacute;e d'un nombre m&ecirc;me si le format &eacute;tait trop court.</P></DIR>
<P ALIGN="JUSTIFY">De plus, la structure de LSD &eacute;tait telle qu'un programme pouvait facilement &ecirc;tre repr&eacute;sent&eacute; en notation polonaise inverse ("cha&icirc;ne post-fix&eacute;e"), dont les avantages sont les suivants :</P><DIR>
<P ALIGN="JUSTIFY">&#149;&#9;facile &agrave; interpr&eacute;ter efficacement,</P>
<P ALIGN="JUSTIFY">&#149;&#9;peu encombrante (environ deux fois moins que le texte source) ; il faut se souvenir que la m&eacute;moire centrale ne faisait que 16 Ko, et qu'il devait y tenir, en plus de la zone de travail de l'utilisateur (programme et 
donn&eacute;es), l'interpr&eacute;teur et le syst&egrave;me ; pour des raisons de performance, ces derniers devaient &ecirc;tre r&eacute;sidents. Une technique d'&eacute;change ("swap") &eacute;tait employ&eacute;e, permettant &agrave; chaque utilisateur d'occuper jusqu'&agrave; environ 10 Ko,</P>
<P ALIGN="JUSTIFY">&#149;&#9;d&eacute;compilable ; ainsi, il n'y avait pas besoin de sauvegarder le texte source (qui aurait encombr&eacute; le disque, et augment&eacute; le temps d'acc&egrave;s) : il &eacute;tait recr&eacute;&eacute;, en cas de listage, 
&agrave; partir de la cha&icirc;ne post-fix&eacute;e.</P></DIR>
<P ALIGN="JUSTIFY">Divers autres points &eacute;taient incorpor&eacute;s pour faciliter la t&acirc;che du programmeur :</P><DIR>
<P ALIGN="JUSTIFY">-&#9;utilisation de mots-cl&eacute;s fran&ccedil;ais (c'&eacute;tait bien la moindre des choses&nbsp;!&nbsp;, mais des mots anglais auraient peut-&ecirc;tre &eacute;t&eacute; mieux venus pour l'avenir du langage...),</P>
<P ALIGN="JUSTIFY">-&#9;langage de commande int&eacute;gr&eacute;, &agrave; la fois concis et explicite : il suffisait de frapper les deux premi&egrave;res lettres de chaque commande, et le syst&egrave;me compl&eacute;tait le libell&eacute; de la commande
 avant de demander ses arguments. Un mode "abr&eacute;g&eacute;" permettait d'&eacute;viter aux utilisateurs avertis la perte de temps caus&eacute;e par la frappe (&agrave; 10 caract&egrave;res/seconde&nbsp;!) de ce compl&eacute;ment,</P>
<P ALIGN="JUSTIFY">-&#9;peu de modes : j'&eacute;tais d&eacute;j&agrave; de l'avis de Larry Tesler, dans son article Don't Mode Me In (The Smalltalk Environment, BYTE Ao&ucirc;t 81) ; il n'y avait donc que deux modes dans le syst&egrave;me, le mode "Ex&eacute;cution"
et le mode "Moniteur". Dans ce dernier mode, l'unit&eacute; d'information &eacute;tait la ligne, et le syst&egrave;me savait s'il avait affaire &agrave; une ligne de commande ou une ligne de programme gr&acirc;ce au num&eacute;ro qui
commen&ccedil;ait chaque ligne de programme (et servait &agrave; indiquer leur ordre d'ex&eacute;cution),</P>
<P ALIGN="JUSTIFY">-&#9;outil de mise au point int&eacute;gr&eacute; : il &eacute;tait possible d'arr&ecirc;ter un programme <U>&agrave; tout moment</U> par appui sur la touche ESC (touche d'interruption), de savoir o&ugrave; il avait &eacute;t&eacute; interrompu, et de demander ou de modifier la valeur de n'importe quel objet ; on pouvait ensuite faire continuer l'ex&eacute;cution sans aucune perte d'information (pas m&ecirc;me un caract&egrave;re si l'arr&ecirc;t avait eu lieu en cours d'impression). La
 m&ecirc;me chose &eacute;tait possible apr&egrave;s arr&ecirc;t sur une instruction PAUSE ou sur une erreur (mais dans ce dernier cas, on ne pouvait &eacute;videmment faire continuer). Cet aspect me paraissait (et me para&icirc;t toujours) tr&egrave;s important, mais il implique une conception adapt&eacute;e et de l'interpr&eacute;teur, et du syst&egrave;me d'exploitation,</P>
<P ALIGN="JUSTIFY">-&#9;gestion de fichiers, limit&eacute;e &agrave; vrai dire aux fichiers programme et ajout&eacute;e apr&egrave;s coup, vers 1970, car nous commencions &agrave; &eacute;puiser les charmes du ruban perfor&eacute;, seul moyen de sauvegarde
auparavant. Elle &eacute;tait con&ccedil;ue selon les m&ecirc;mes principes que la gestion m&eacute;moire, &agrave; savoir rapidit&eacute; et allocation dynamique ; pour ne pas prendre sur l'espace m&eacute;moire des utilisateurs (et voir arriver des gens se plaindre que "bien qu'ils n'aient rien chang&eacute;", leur programme n'entre plus en m&eacute;moire), elle &eacute;tait r&eacute;alis&eacute;e en recouvrement sur l'interpr&eacute;teur,</P>
<P ALIGN="JUSTIFY">-&#9;d&eacute;tection rapide d'erreurs (gr&acirc;ce &agrave; la compilation ligne &agrave; ligne) et compl&egrave;te (en particulier, d&eacute;tection de l'emploi d'objets non initialis&eacute;s).</P></DIR>
<P ALIGN="JUSTIFY">Au niveau du syst&egrave;me d'exploitation, toujours pour essayer de satisfaire au mieux l'utilisateur, on s'&eacute;tait fait un point d'honneur &agrave; lui faire croire que l'ordinateur &eacute;tait rapide, en particulier gr&acirc;ce
 au passage en priorit&eacute; des travaux courts (un algorithme fort simple avait &eacute;t&eacute; trouv&eacute; pour d&eacute;tecter les "travaux courts"), gr&acirc;ce &agrave; la simultan&eacute;it&eacute; entre les traitements et l'impression, etc.
Par exemple, le temps de compilation (analyse syntaxique et g&eacute;n&eacute;ration de la cha&icirc;ne post-fix&eacute;e) &eacute;tait en g&eacute;n&eacute;ral invisible, car recouvert par le temps d'impression des caract&egrave;res faisant passer &agrave;
la ligne le terminal.</P>
<P ALIGN="JUSTIFY">De m&ecirc;me, on s'&eacute;tait efforc&eacute; de tout mettre en &#156;uvre pour qu'un programme ne soit jamais perdu par la faute du syst&egrave;me, m&ecirc;me en cas de "plantage". D'ailleurs, ceux-ci ne devaient pas exister (et cess&egrave;rent assez vite d'exister, gr&acirc;ce &agrave; une traque opini&acirc;tre des anomalies).</P>
<P ALIGN="JUSTIFY">Les r&eacute;sultats ont &eacute;t&eacute; tout &agrave; fait &agrave; la hauteur des efforts, les utilisateurs se sont d&eacute;clar&eacute;s ravis des temps de r&eacute;ponse (ou, plus exactement, ils ont trouv&eacute; cela normal...)
, et pourtant le syst&egrave;me g&eacute;rait treize terminaux ; les critiques venaient par contre du bruit des t&eacute;l&eacute;types, de leur lenteur et du manque de temps disponible (le syst&egrave;me ne fonctionnait qu'entre 12 h et 14 h, &agrave; cause de l'organisation des &eacute;tudes &agrave; Sup-&Eacute;lec et de l'utilisation du 1130 l'apr&egrave;s-midi par les &eacute;l&egrave;ves de la section Informatique). </P>
<P ALIGN="JUSTIFY">&Agrave; titre indicatif, les t&acirc;ches &eacute;taient r&eacute;parties entre les deux machines de la fa&ccedil;on suivante :</P><DIR>

<P ALIGN="JUSTIFY">1130 : interpr&eacute;tation, gestion de fichiers, gestion du "swap", gestion de l'acc&egrave;s aux objets en mode "mise au point",</P>
<P ALIGN="JUSTIFY">2116 : compilation, d&eacute;compilation, analyse des commandes, gestion des terminaux, gestion de l'arr&ecirc;t du syst&egrave;me et des coupures/retours secteurs, gestion du temps partag&eacute;.</P></DIR>
<P ALIGN="JUSTIFY">Il est bien &eacute;vident que tout le logiciel de ces deux machines avait d&ucirc; &ecirc;tre r&eacute;&eacute;crit, soit pour &eacute;conomiser de la place, soit pour satisfaire aux fonctionnalit&eacute;s du syst&egrave;me (en particu
lier, la sp&eacute;cification qu'un programme en cours d'ex&eacute;cution puisse &ecirc;tre interrompu imm&eacute;diatement &agrave; tout moment, m&ecirc;me en cours d'impression, ce qui avait men&eacute; &agrave; l'&eacute;criture d'un pilote de terminal
 tirant astucieusement parti d'une caract&eacute;ristique du coupleur 2116, caract&eacute;ristique probablement li&eacute;e &agrave; l'&eacute;conomie d'une porte ET de la part de son concepteur...) ; de m&ecirc;me, une m&eacute;thode originale de compilation avait &eacute;t&eacute; d&eacute;velopp&eacute;e pour obtenir un compilateur &agrave; la fois rapide, peu encombrant et fiable (ne laissant en particulier passer aucune erreur, toute cha&icirc;ne post-fix&eacute;e 
incorrecte risquant de cr&eacute;er une catastrophe au moment de l'ex&eacute;cution ou de la d&eacute;compilation).</P>
<P ALIGN="JUSTIFY">Ont particip&eacute; &agrave; ce projet :</P><DIR>
<P ALIGN="JUSTIFY">-&#9;S. Berche (utilitaires vari&eacute;s, en particulier conversion astucieuse en virgule flottante)</P>
<P ALIGN="JUSTIFY">-&nbsp;E. Fizzarotti (d&eacute;compilateur)</P>
<P ALIGN="JUSTIFY">-&nbsp;P. Gavarini (compilateur)</P>
<P ALIGN="JUSTIFY">-&nbsp;Y. Noyelle (conception et d&eacute;finition du langage, interpr&eacute;teur, gestion de fichier, syst&egrave;me de la 1130)</P>
<P ALIGN="JUSTIFY">-&nbsp;J-Ph. Szylowicz (r&eacute;alisation de la liaison mat&eacute;rielle 1130-2116, syst&egrave;me de la 2116, gestion des terminaux et id&eacute;e initiale du d&eacute;compilateur)</P></DIR>
<B><P ALIGN="JUSTIFY">LSE</P>
</B><P ALIGN="JUSTIFY">La saga du LSE suit celle du LSD, et son origine est le colloque CERI/OCDE de S&egrave;vres (Mars 1970) o&ugrave; il avait &eacute;t&eacute; d&eacute;battu de ce que l'informatique pourrait apporter &agrave; l'enseignement. La d&eacute;cision ayant &eacute;t&eacute; prise d'installer des ordinateurs, &agrave; titre exp&eacute;rimental, dans quelques lyc&eacute;es, restait &agrave; choisir le langage qui serait employ&eacute; pour les programmer. L'un des participants du colloque de 
S&egrave;vres &eacute;tait Jacques Hebenstreit, Chef du service Informatique de l'ESE, qui proposa le LSD pour les raisons suivantes :</P><DIR>
<P ALIGN="JUSTIFY">-&#9;il comportait un noyau initial facile &agrave; apprendre, tout en &eacute;tant relativement puissant (notamment &agrave; cause des proc&eacute;dures), </P>
<P ALIGN="JUSTIFY">-&#9;il &eacute;tait manifestement r&eacute;alisable de mani&egrave;re efficace sur des petits ordinateurs (les cr&eacute;dits allou&eacute;s pour cette exp&eacute;rience n'&eacute;taient pas &eacute;normes),</P>
<P ALIGN="JUSTIFY">-&#9;il "parlait" fran&ccedil;ais (il ne fallait pas donner aux utilisateurs l'impression que informatique &eacute;tait synonyme d'anglophonie),</P>
<P ALIGN="JUSTIFY">-&#9;il ne n&eacute;cessitait pas de personnel sp&eacute;cialis&eacute; (op&eacute;rateur, etc.).</P></DIR>
<P ALIGN="JUSTIFY">Apr&egrave;s une d&eacute;monstration sur un programme de calcul d'amplificateur &agrave; transistor, LSD fut choisi comme langage support de l'introduction de l'informatique dans l'enseignement, &agrave; deux conditions :</P><DIR>
<P ALIGN="JUSTIFY">-&#9;que son nom soit chang&eacute;...,</P>
<P ALIGN="JUSTIFY">-&#9;qu'on le rende exploitable, non seulement par des scientifiques, mais &eacute;galement par les autres enseignants d'un lyc&eacute;e.</P></DIR>
<P ALIGN="JUSTIFY">Ainsi naquit LSE, successeur de LSD (E est la lettre qui suit D) ; il y avait deux significations initiales &agrave; cet acronyme :</P><DIR>
<P ALIGN="JUSTIFY">-&#9;Langage Symbolique d'Enseignement,</P>
<P ALIGN="JUSTIFY">-&#9;Langage de Sup-&Eacute;lec,</P></DIR>
<P ALIGN="JUSTIFY">et d'autres sont venus apr&egrave;s : Langage Simple &agrave; Enseigner, Langage Sans Espoir (ce dernier nom donn&eacute; &eacute;videmment par les inconditionnels de BASIC&nbsp;!).</P>
<P ALIGN="JUSTIFY">Apr&egrave;s une r&eacute;flexion, guid&eacute;e essentiellement par J. Hebenstreit, pour rendre LSE le plus universel possible, il fut d&eacute;cid&eacute; d'ajouter le type "cha&icirc;ne de caract&egrave;res", le texte paraissant le
d&eacute;nominateur commun de nombreuses activit&eacute;s d'enseignement.</P>
<P ALIGN="JUSTIFY">Il restait &agrave; d&eacute;finir des op&eacute;rations pratiques portant sur ce type de donn&eacute;es, ce que je fis de Juin &agrave; Septembre 1971, en m'appuyant sur les sources suivantes :</P><DIR>
<P ALIGN="JUSTIFY">-&#9;une connaissance de LISP, qui me faisait envisager sans inqui&eacute;tude la gestion d'objets de taille variable,</P>
<P ALIGN="JUSTIFY">-&#9;les fonctionnalit&eacute;s similaires du langage PL/1,</P>
<P ALIGN="JUSTIFY">-&#9;une remarque de J-Ph. Szylowicz, me conseillant de chercher les op&eacute;rations les plus courantes effectu&eacute;es par un programme manipulant du texte (en l'occurrence le compilateur LSD).</P></DIR>
<P ALIGN="JUSTIFY">&Agrave; cette occasion, S. Berche donna une solution &eacute;l&eacute;gante au probl&egrave;me de la d&eacute;finition d'une sous-cha&icirc;ne, non par sa longueur, mais par un caract&egrave;re d'arr&ecirc;t (ou un ensemble de caract&egrave;res d'arr&ecirc;t).</P>
<P ALIGN="JUSTIFY">J'en profitais pour am&eacute;liorer d'autres points de LSD :</P><DIR>
<P ALIGN="JUSTIFY">-&#9;introduire une instruction de boucle, d&eacute;riv&eacute;e de celle d'ALGOL,</P>
<P ALIGN="JUSTIFY">-&#9;am&eacute;liorer l'instruction d'&eacute;criture (facteur de r&eacute;p&eacute;tition variable, sortie d'un nombre sous la forme la plus agr&eacute;able possible, &eacute;limination du format dans les cas simples),</P>
<P ALIGN="JUSTIFY">-&#9;ajouter des fonctions diverses donnant la date, un nombre pseudo ou r&eacute;ellement al&eacute;atoire, etc.,</P>
<P ALIGN="JUSTIFY">-&#9;introduire des fichiers donn&eacute;es permanents et temporaires, dot&eacute;s de plusieurs caract&eacute;ristiques originales, toujours pour faciliter la vie du programmeur :</P><DIR>
<P ALIGN="JUSTIFY">&#149;&#9;un enregistrement contenait un (et un seul) objet complet, et le type de celui-ci ; ainsi l'exploitation d'un fichier &eacute;tait extr&ecirc;mement simple,</P>
<P ALIGN="JUSTIFY">&#149;&#9;chaque enregistrement &eacute;tait muni d'une cl&eacute; num&eacute;rique arbitraire, l'acc&egrave;s se faisant selon cette cl&eacute; et non s&eacute;quentiellement,</P>
<P ALIGN="JUSTIFY">&#149;&#9;un espace temporaire de taille bien d&eacute;finie &eacute;tait garanti &agrave; chaque utilisateur ; ainsi, un programme utilisant des fichiers temporaires de taille fixe, s'il &eacute;tait d&eacute;j&agrave; pass&eacute; une
 fois, &eacute;tait s&ucirc;r de ne pas se faire avorter ult&eacute;rieurement par manque d'espace fichier, quel que soit le degr&eacute; de remplissage &agrave; ce moment de la m&eacute;moire auxiliaire,</P>
<P ALIGN="JUSTIFY">&#149;&#9;pas de notion d'ouverture ou de fermeture inflig&eacute;e &agrave; l'utilisateur, celles-ci &eacute;tant implicites et dynamiques.</P></DIR>

<P ALIGN="JUSTIFY">-&#9;introduire une instruction de liaison, permettant, pour un programme d&eacute;compos&eacute; en plusieurs modules, de faire charger un module &agrave; la place du pr&eacute;c&eacute;dent (la communication entre deux modules se faisant via les fichiers).</P></DIR>
<P ALIGN="JUSTIFY">Au niveau du langage de commande, les fonctionnalit&eacute;s suivantes &eacute;taient ajout&eacute;es :</P><DIR>
<P ALIGN="JUSTIFY">-&#9;outils de manipulation de programme : plut&ocirc;t que d'introduire des outils vari&eacute;s, comme &eacute;diteur de texte ou &eacute;diteur de liens, la solution retenue &eacute;tait de donner la possibilit&eacute; de "d&eacute;coder"
ou "d'encoder" un programme, c'est-&agrave;-dire de passer d'un programme &agrave; un fichier de texte repr&eacute;sentant son source, et r&eacute;ciproquement ; la manipulation du source se faisait alors par un autre programme &eacute;crit en LSE, 
utilisant ses caract&eacute;ristiques de gestion de texte et de fichier,</P>
<P ALIGN="JUSTIFY">-&#9;syst&egrave;me de protection des fichiers, &agrave; base "d'identifications" (num&eacute;ro + cl&eacute; secr&egrave;te) ; il y avait aussi un syst&egrave;me de protection des programmes charg&eacute;s en m&eacute;moire, les rendant
non listables et non modifiables, afin d'&eacute;viter qu'un utilisateur de didacticiel aille consulter le texte du programme pour savoir la r&eacute;ponse attendue, au lieu de la trouver tout seul...,</P>
<P ALIGN="JUSTIFY">-&#9;mode d'ex&eacute;cution imm&eacute;diate, permettant de voir facilement l'effet d'une instruction (avec certaines restrictions sur les instructions ex&eacute;cutables dans ce mode) ; ceci donnait en particulier la possibilit&eacute;
d'effectuer des calculs comme avec une calculette &agrave; m&eacute;moire, et de visualiser ou de modifier les objets d'un programme interrompu,</P>
<P ALIGN="JUSTIFY">-&#9;extension des outils de mise au point par ajout d'une possibilit&eacute; de pas &agrave; pas et de point d'arr&ecirc;t.</P></DIR>
<P ALIGN="JUSTIFY">Le rapport de d&eacute;finition de LSE fut remis au Minist&egrave;re de l'&Eacute;ducation Nationale (Mission &agrave; l'Informatique) en Octobre 1971 ; il restait encore &agrave; r&eacute;aliser le syst&egrave;me de programmation et le
 syst&egrave;me d'exploitation en temps partag&eacute; pour au moins 9 terminaux (selon les sp&eacute;cifications du Minist&egrave;re) sur les deux machines retenues : les mini-ordinateurs T1600 de T&eacute;l&eacute;m&eacute;canique et MITRA-15 de SEMS,
avec comme date limite Septembre 1972 (rentr&eacute;e scolaire).</P>
<P ALIGN="JUSTIFY">Les gens de T&eacute;l&eacute;m&eacute;canique mirent le paquet sur ce projet, nous demandant &eacute;galement de leur servir de conseil ; ils tinrent (presque) les d&eacute;lais, et livr&egrave;rent deux syst&egrave;mes fin Octobre 1972.
Ces syst&egrave;mes tournaient sur des machines de 16 Ko de m&eacute;moire centrale, avec un disque rapide de 256 Ko.</P>
<P ALIGN="JUSTIFY">Quant &agrave; la SEMS, le projet semblait l'int&eacute;resser beaucoup moins ; elle nous confia le soin de le r&eacute;aliser, ce que nous f&icirc;mes sur une machine dot&eacute;e d'un disque rapide de 384 Ko et de 8 Ko de m&eacute;moire 
centrale. Inutile de dire que ce fut du sport de faire tenir tout ce qui &eacute;tait n&eacute;cessaire dans cette petite m&eacute;moire, d'autant que nous voulions qu'il y ait assez de place en zone utilisateur pour y faire tenir un module de fonctionnalit&eacute;s &eacute;quivalentes &agrave; celles d'un programme d'environ 300 lignes de FORTRAN.</P>
<P ALIGN="JUSTIFY">De nombreuses techniques furent mises en &#156;uvre, en particulier des techniques de compactage et de recouvrement dynamique, permettant de configurer en m&eacute;moire le sous-ensemble de l'interpr&eacute;teur tel que le programme courant
 puisse s'ex&eacute;cuter avec le minimum d'acc&egrave;s disque. De m&ecirc;me, seule une toute petite partie des tampons associ&eacute;s aux terminaux &eacute;tait r&eacute;sidente, le reste &eacute;tant plac&eacute; sur disque, mais n&eacute;anmoins
 dispos&eacute; de mani&egrave;re &agrave; garantir un d&eacute;bit minimal de 600 bauds sur chacun des terminaux (nous avions pr&eacute;vu le syst&egrave;me pour 16 terminaux). Ceci nous permit de donner la moiti&eacute; de la zone m&eacute;moire (4 Ko) 
&agrave; chaque utilisateur (avec encore une technique d'&eacute;change, bien entendu).</P>
<P ALIGN="JUSTIFY">Pour obtenir un bon temps de r&eacute;ponse (bien inf&eacute;rieur &agrave; la demi-seconde en g&eacute;n&eacute;ral, c'est-&agrave;-dire encore meilleur qu'en LSD), nous dispos&acirc;mes les diff&eacute;rentes branches des structures de
 recouvrement statiques (compilateur, d&eacute;compilateur, etc.) de fa&ccedil;on &agrave; ce que le d&eacute;lai rotationnel du disque lors de leur acc&egrave;s soit minimal, et nous nous efforc&acirc;mes de les charger le moins souvent possible. </P>
<P ALIGN="JUSTIFY">Deux raisons nous avaient incit&eacute;es &agrave; entreprendre ces exercices de haute voltige :</P><DIR>
<P ALIGN="JUSTIFY">-&#9;faire en sorte que les utilisateurs puissent disposer d'un disque de 384 Ko (la diff&eacute;rence de prix avec celui de 192 Ko &eacute;tait quasiment le co&ucirc;t des 8 Ko de m&eacute;moire &eacute;conomis&eacute;s),</P>
<P ALIGN="JUSTIFY">-&#9;quelques remarques (de personnes ext&eacute;rieures &agrave; l'ESE) insinuant que nous n'y arriverions pas...</P></DIR>
<P ALIGN="JUSTIFY">Mais ce ciselage prit du temps, et nous ne livr&acirc;mes qu'une version tr&egrave;s primitive du syst&egrave;me en D&eacute;cembre 1972, avec deux bons mois de retard, le syst&egrave;me complet se faisant encore attendre jusqu'en Juin 
1973. Ceci valu des p&eacute;nalit&eacute;s &agrave; la SEMS, &agrave; laquelle le Minist&egrave;re commanda moins de machines qu'&agrave; T&eacute;l&eacute;m&eacute;canique, mais nous nous consol&acirc;mes en constatant que les performances de notre syst&egrave;me &eacute;taient entre trois et quatre fois meilleures que celles du syst&egrave;me concurrent.</P>
<P ALIGN="JUSTIFY">Au point de vue fiabilit&eacute;, les produits &eacute;taient tr&egrave;s bons tout les deux ; mais je me souviens encore d'une version de notre syst&egrave;me livr&eacute;e avec une grosse erreur (une virgule mal plac&eacute;e dans une
 ligne &agrave; compiler tuait tout le syst&egrave;me), erreur d&eacute;tect&eacute;e et corrig&eacute;e tr&egrave;s rapidement ; mais entre-temps une copie de cette version &eacute;tait partie vers les machines utilis&eacute;es par le DEUG de PARIS VI,
 sans que la correction de l'erreur suive, ce qui fait que pendant au moins deux ans (avant que nous n'en ayons l'&eacute;cho) les utilisateurs de ce syst&egrave;me ont d&ucirc; pester contre la qualit&eacute; du logiciel Sup-&Eacute;lec&nbsp;!</P>
<P ALIGN="JUSTIFY">Ont particip&eacute; au projet LSE :</P><DIR>
<P ALIGN="JUSTIFY">-&#9;S. Berche (interpr&eacute;teur)</P>
<P ALIGN="JUSTIFY">-&#9;J. Hebenstreit (id&eacute;e que le texte &eacute;tait le d&eacute;nominateur commun des activit&eacute;s d'enseignement, et que donc le langage devait pouvoir le manipuler facilement ; r&eacute;flexions plus g&eacute;n&eacute;rales
 sur l'apport de l'informatique &agrave; l'enseignement)</P>
<P ALIGN="JUSTIFY">-&#9;C. Lhermitte (d&eacute;compilateur)</P>
<P ALIGN="JUSTIFY">-&#9;Y. Noyelle (d&eacute;finition de LSE et r&eacute;daction du rapport correspondant, analyseur de commande, syst&egrave;me d'exploitation, syst&egrave;me de gestion de fichier)</P>
<P ALIGN="JUSTIFY">-&#9;P. Pressigout (compilateur)</P></DIR>
<B><P ALIGN="JUSTIFY">Norme LSE</P>
</B><P ALIGN="JUSTIFY">Ceci n'&eacute;tait pas la fin de la saga du LSE ; apr&egrave;s l'interruption de l'&eacute;quipement des lyc&eacute;es en mini-ordinateurs (1976), l'op&eacute;ration des "10 000 micro" vint la r&eacute;veiller en 1979. Une commissi
on fut alors &eacute;tablie au sein de l'AFNOR, dans le but de r&eacute;diger une norme d&eacute;finissant sans ambigu&iuml;t&eacute; le langage et l'environnement de programmation associ&eacute; ; ainsi, la portabilit&eacute; des programmes pourrait &ecirc;tre garantie d'une r&eacute;alisation &agrave; l'autre, et une coh&eacute;rence d'emploi respect&eacute;e.</P>
<P ALIGN="JUSTIFY">&Agrave; cette occasion, et apr&egrave;s consultation des utilisateurs, des extensions furent apport&eacute;es au langage, en particulier la possibilit&eacute; d'appeler des proc&eacute;dures compil&eacute;es s&eacute;par&eacute;ment et
 charg&eacute;es dynamiquement (proc&eacute;dures externes), la possibilit&eacute; de compiler dynamiquement une proc&eacute;dure (pour r&eacute;soudre le probl&egrave;me de l'utilisation dans un programme de formules entr&eacute;es au clavier), la notion
 de p&eacute;riph&eacute;rique logique, la possibilit&eacute; de verrouiller un fichier ou un enregistrement pour &eacute;viter des mises &agrave; jour simultan&eacute;es (utilisation multi-poste ou en r&eacute;seau), les types bool&eacute;en et
 num&eacute;rique-&eacute;tendu, ce dernier permettant de faire des calculs de pr&eacute;cision arbitrairement grande, la possibilit&eacute; d'appeler des fonctions &eacute;crites dans un autre langage, la possibilit&eacute; de comparer
 des cha&icirc;nes de caract&egrave;res selon un ordre lexicographique quelconque, ainsi que d'autres am&eacute;liorations ponctuelles.</P>
<P ALIGN="JUSTIFY">Les principaux participants &agrave; la r&eacute;daction de cette norme ont &eacute;t&eacute; :</P><DIR>
<P ALIGN="JUSTIFY">-&#9;B. Commiot (ENS St Cloud)</P>
<P ALIGN="JUSTIFY">-&#9;J.P. Lamoitier (ing&eacute;nieur-conseil)</P>
<P ALIGN="JUSTIFY">-&#9;B. Leroy (CII-HB)</P>
<P ALIGN="JUSTIFY">-&#9;P. Muller (INRP)</P>
<P ALIGN="JUSTIFY">-&#9;Y. Noyelle (ESE)</P>
<P ALIGN="JUSTIFY">-&#9;J. Robert (CAP SOGETI)</P></DIR>
<P ALIGN="JUSTIFY">Gr&acirc;ce &agrave; (ou malgr&eacute;) de nombreuses pressions et contre-pressions d'ordre non technique, la r&eacute;daction de cette norme a &eacute;t&eacute; termin&eacute;e en Juillet 1982.</P>
<P ALIGN="JUSTIFY">Une autre extension importante de LSE fut l'introduction (post&eacute;rieure &agrave; la norme) de fonctionnalit&eacute;s graphiques (trac&eacute; de vecteurs, notion de "motif", etc.), fonctionnalit&eacute;s r&eacute;cup&eacute;r&eacute;es
 du langage LSG (voir plus loin).</P>
<P ALIGN="JUSTIFY">Il restait &agrave; r&eacute;aliser le syst&egrave;me correspondant sur les diverses machines choisies par l'&Eacute;ducation Nationale ; comme nous avons refus&eacute; de le faire (arguant du fait que r&eacute;aliser une fois un syst&egrave;me
 LSE pouvait &ecirc;tre qualifi&eacute; de recherche, vu ses aspects novateurs, mais que le r&eacute;aliser en s&eacute;rie n'&eacute;tait plus de notre ressort), trois soci&eacute;t&eacute;s se sont mont&eacute;es pour satisfaire &agrave; la demande, les soci&eacute;t&eacute;s MICRODUR, EDL et, plus r&eacute;cemment, LOGICIA.</P>
<B><P ALIGN="JUSTIFY">&Eacute;tat actuel du LSE</P>
</B><P ALIGN="JUSTIFY">Finalement, malgr&eacute; son peu de diffusion, LSE existe toujours, non seulement sur les mat&eacute;riels &Eacute;ducation Nationale (o&ugrave; il devait par contrat &ecirc;tre implant&eacute; , ce que tous les fournisseurs sauf un,
 le plus important, ont fait), mais encore sur tous les compatibles PC, le Macintosh, des mat&eacute;riels COMMODORE, etc.</P>
<P ALIGN="JUSTIFY">On peut se demander pourquoi il n'a pas eu plus de succ&egrave;s, car il semblait r&eacute;pondre de mani&egrave;re tout &agrave; fait satisfaisante aux crit&egrave;res sp&eacute;cifi&eacute;s ; en particulier il &eacute;tait, sur de
 nombreux points, bien sup&eacute;rieur &agrave; BASIC. Peut-&ecirc;tre d&eacute;routait-il les r&eacute;alisateurs potentiels par son aspect dynamique&nbsp;? Nous aurions d&ucirc; publier les m&eacute;thodes permettant de le mettre en &#156;uvre, m&eacute;thodes
 pourtant simples et syst&eacute;matiques comme le prouve le faible encombrement du logiciel n&eacute;cessaire (environ 37 Ko au total sur MITRA, y compris le syst&egrave;me d'exploitation en temps partag&eacute;).</P>
<P ALIGN="JUSTIFY">Il avait aussi quelques d&eacute;fauts&#133; Au moins une tentative ext&eacute;rieure &agrave; l'ESE a &eacute;t&eacute; faite pour les corriger, celle de J. Arsac avec LSE83 (cf. bibliographie), mais elle sacrifie la compatibilit&eacute;.</P>
<B><P ALIGN="JUSTIFY">LSG</P>
</B><P ALIGN="JUSTIFY">LSG (Langage Symbolique Graphique) a &eacute;t&eacute; d&eacute;fini en 1972 par Jean Le Bourdon (&eacute;galement du service informatique de l'ESE) ; son but &eacute;tait de donner le moyen de tirer le meilleur parti possible d'outils graphiques &eacute;conomiques (en particulier consoles), en vue d'application &agrave; la CAO et  &agrave; l'EAO.</P>
<P ALIGN="JUSTIFY">Tout comme LSE, le langage devait &ecirc;tre conversationnel, donner des outils puissants, mais rester d'utilisation simple et donc manipuler des concepts faciles &agrave; ma&icirc;triser.</P>
<P ALIGN="JUSTIFY">Les entit&eacute;s introduites &eacute;taient principalement :</P><DIR>
<P ALIGN="JUSTIFY">-&#9;la notion d'item, compos&eacute; d'une description de forme graphique (formes &eacute;l&eacute;mentaires : point, vecteur, cercle, etc., et d&eacute;riv&eacute;s de ces formes obtenus par rotation, sym&eacute;trie, concat&eacute;nation,
 superposition, etc.), et d'une liste de valeurs associ&eacute;es, permettant de donner une s&eacute;mantique &agrave; l'item : ainsi, on pouvait d&eacute;finir un item "condensateur 10nF 20%" en associant une forme graphique (suite de vecteurs
 repr&eacute;sentant le dessin d'un condensateur) et les valeurs 10nF et 20%,</P>
<P ALIGN="JUSTIFY">-&#9;la notion de motif, qui repr&eacute;sentait une sous-image graphique ; ainsi, dans un sch&eacute;ma avec beaucoup de composants identiques, le dessin d'un composant correspondait &agrave; un motif, qui pouvait ensuite &ecirc;tre
 r&eacute;p&eacute;t&eacute; un grand nombre de fois de mani&egrave;re tr&egrave;s facile pour l'utilisateur et tr&egrave;s compacte pour l'ordinateur,</P>
<P ALIGN="JUSTIFY">-&#9;la notion de cible, permettant d'indiquer de mani&egrave;re interactive un point d'un dessin sur l'&eacute;cran et de remonter jusqu'&agrave; l'item correspondant.</P></DIR>
<P ALIGN="JUSTIFY">LSG a &eacute;t&eacute; con&ccedil;u comme une extension de LSE, utilisant ce dernier pour effectuer les traitements sur les valeurs associ&eacute;es aux items ; il avait &eacute;t&eacute; ajout&eacute; pour cette application un mode de
 passage par nom, mode n&eacute;cessaire si l'on veut pouvoir passer en param&egrave;tre les expressions d&eacute;crivant des courbes.</P>
<P ALIGN="JUSTIFY">Ont particip&eacute; &agrave; la r&eacute;alisation de LSG :</P><DIR>
<P ALIGN="JUSTIFY">-&#9;D. Clar (d&eacute;veloppement d'une version portable de LSE, &eacute;crite en FORTRAN, et adaptations diverses)</P>
<P ALIGN="JUSTIFY">-&#9;J. Le Bourdon (primitives graphiques et interface multi-p&eacute;riph&eacute;rique)</P>
<P ALIGN="JUSTIFY">-&#9;B. Vivinis (maquettes initiales)</P></DIR>
<P ALIGN="JUSTIFY">Ce travail a &eacute;t&eacute; r&eacute;alis&eacute; sur contrat avec la D&eacute;l&eacute;gation &agrave; l'Informatique du Minist&egrave;re du D&eacute;veloppement Industriel et Scientifique (anc&ecirc;tre de l'ADI).</P>
<B><P ALIGN="JUSTIFY">LST</P>
</B><P ALIGN="JUSTIFY">Un autre rejeton de LSE, implant&eacute; dans l'industrie et toujours bien vivant, est le LST (Langage Symbolique de Test), qui a &eacute;t&eacute; d&eacute;velopp&eacute; dans les ann&eacute;es 1973-1976 &agrave; la demande de la soci&eacute;t&eacute; Thomson-CSF.</P>
<P ALIGN="JUSTIFY">Son historique est le suivant : plusieurs divisions de cette soci&eacute;t&eacute; font du test automatique de composants et de sous-syst&egrave;mes produits en petites s&eacute;ries, et recherchaient pour ce faire un langage d'apprentissage
 ais&eacute; pour des non-informaticiens, permettant d'&eacute;crire des programmes faciles &agrave; modifier et &agrave; (re-)mettre au point, et fonctionnant sous syst&egrave;me en temps partag&eacute; de mani&egrave;re &agrave; limiter le co&ucirc;t
 unitaire du poste de test. Il leur fallait &eacute;galement un syst&egrave;me fiable ; de plus, une fausse manipulation sur un terminal ou un &eacute;quipement de test devait &ecirc;tre r&eacute;cup&eacute;rable, et ne pas avoir de cons&eacute;quence pour les autres utilisateurs.</P>
<P ALIGN="JUSTIFY">Initialement, un syst&egrave;me Hewlett-Packard avait &eacute;t&eacute; employ&eacute;, avec BASIC comme langage ; mais ensuite avait &eacute;t&eacute; prise la d&eacute;cision d'utiliser du mat&eacute;riel CII, et donc le MITRA-15. Comme
 un BASIC fiable et multiposte sur cette machine tardait &agrave; venir, il leur fut propos&eacute; LSE qui, apr&egrave;s essais, fut adopt&eacute; &agrave; l'unanimit&eacute; de la commission "Automatisation des Essais", moyennant deux extensions principales :</P><DIR>
<P ALIGN="JUSTIFY">-&#9;augmenter la taille de la zone de travail (il suffisait d'&eacute;tendre la m&eacute;moire),</P>
<P ALIGN="JUSTIFY">-&#9;pouvoir g&eacute;rer n'importe quel p&eacute;riph&eacute;rique, et mettre au repos une t&acirc;che en attente d'un &eacute;v&eacute;nement.</P></DIR>
<P ALIGN="JUSTIFY">Cette seconde extension posait de s&eacute;rieux probl&egrave;mes ; ils furent r&eacute;solus en donnant la possibilit&eacute; d'&eacute;crire des proc&eacute;dures externes en langage d'assemblage, dot&eacute;es des m&ecirc;mes modes
 d'appel et de communication que les proc&eacute;dures LSE, et chargeables dynamiquement, soit dans la  zone utilisateur, soit dans une zone r&eacute;sidente commune ; l&agrave;, on pouvait les d&eacute;clarer "clou&eacute;es", et donc g&eacute;rer des
 interruptions. Ainsi, moyennant l'ajout de quelques appels syst&egrave;mes (communication avec l'appelant, mise au repos d'une t&acirc;che, acc&egrave;s &agrave; des fonctions de calcul) et gr&acirc;ce &agrave; l'architecture astucieuse du MITRA-15 (existence
 d'un vrai registre de base en particulier), on obtenait un syst&egrave;me pouvant se configurer dynamiquement, et en particulier g&eacute;rer n'importe quel nouveau p&eacute;riph&eacute;rique sans modification (ceci &agrave;
 comparer avec les "g&eacute;n&eacute;rations de syst&egrave;me" fr&eacute;quemment n&eacute;cessaires pour ajouter un pilote &agrave; un syst&egrave;me classique).</P>
<P ALIGN="JUSTIFY">On avait &eacute;galement donn&eacute; la possibilit&eacute; de cr&eacute;er/supprimer des t&acirc;ches, d'ajouter &agrave; l'infini des commandes (pour un poste particulier, ou pour plusieurs postes), toujours dynamiquement, et de rendre
 partageables les proc&eacute;dures externes r&eacute;sidentes (qu'elles soient &eacute;crites en assembleur ou en LSE).</P>
<P ALIGN="JUSTIFY">Un syst&egrave;me de protection logiciel faisait que seuls les utilisateurs autoris&eacute;s pouvaient passer en mode ma&icirc;tre, ou utiliser les appels syst&egrave;mes dangereux. Ceci, joint au m&eacute;canisme de protection m&eacute;moire
 du MITRA, faisait que la fiabilit&eacute; restait excellente.</P>
<P ALIGN="JUSTIFY">Pour avoir une cha&icirc;ne compl&egrave;te de d&eacute;veloppement, un assembleur (assez lent &agrave; vrai dire) et les utilitaires associ&eacute;s (&eacute;diteur de texte, etc.) avaient &eacute;t&eacute; &eacute;crits en LSE ; les
 outils de mise au point avaient &eacute;t&eacute; adapt&eacute;s en cons&eacute;quence.</P>
<P ALIGN="JUSTIFY">Ce syst&egrave;me fonctionne toujours chez Thomson-CSF ; il semble donner satisfaction puisque, quand les MITRA-15 n'ont plus &eacute;t&eacute; fabriqu&eacute;s, un compatible MITRA, baptis&eacute; CMP-16, a &eacute;t&eacute;
 d&eacute;velopp&eacute; pour continuer &agrave; l'utiliser ; environ 600 exemplaires du CMP-16 ont &eacute;t&eacute; produits. Actuellement, LST est en cours de portage sous UNIX.</P>
<P ALIGN="JUSTIFY">Les extensions menant &agrave; LST ont &eacute;t&eacute; d&eacute;velopp&eacute;es conjointement par Y. Noyelle et S. Berche, mais c'est gr&acirc;ce &agrave; ce dernier qu'elles ont vu le jour : en effet, je trouvais &agrave; l'origine 
que les modifications demand&eacute;es &eacute;taient peu syst&eacute;matiques (elles &eacute;taient beaucoup plus disparates que ce qui pr&eacute;c&egrave;de peut laisser croire), et donc sans int&eacute;r&ecirc;t. Mais nous avons r&eacute;ussi &agrave; 
les rendre coh&eacute;rentes et homog&egrave;nes, ce qui a permis de transformer LSE en un syst&egrave;me ouvert (moyennant un minimum de 8 Ko en plus).</P>
<B><P ALIGN="JUSTIFY">Conclusion</P>
</B><P ALIGN="JUSTIFY">Le d&eacute;veloppement des LSx s'est &eacute;tendu sur neuf ann&eacute;es (1968-1976), avec quelques interruptions. Il nous a permis de tester les id&eacute;es que nous avions sur les langages de programmation et sur les syst&egrave;mes
 d'exploitation (en particulier au niveau de la "convivialit&eacute;"), et a &eacute;t&eacute; tr&egrave;s instructif pour notre t&acirc;che principale, l'enseignement. En effet, bien que le travail fourni soit important (de l'ordre de deux homme-ann&eacute;e
 pour chacun des quatre projets), il a &eacute;t&eacute; effectu&eacute; globalement &agrave; mi-temps, l'autre mi-temps &eacute;tant consacr&eacute;e en gros &agrave; enseigner.</P>
<P ALIGN="JUSTIFY">Les LSx nous ont permis d'explorer des concepts novateurs (types cha&icirc;ne de caract&egrave;res et num&eacute;rique-&eacute;tendu, fichiers d'utilisation simple, primitives de synchronisation pour LST, items et motifs pour LSG, etc.)
, et de les mettre en &#156;uvre, non seulement pour les ma&icirc;triser, mais &eacute;galement pour en assurer une r&eacute;alisation industrielle. Ceci nous a notamment permis d'affiner une d&eacute;marche "qualit&eacute; du logiciel", bas&eacute;e en
 particulier sur des batteries de tests enrichies &agrave; chaque anomalie, et sur la pratique de la relecture du code &eacute;crit par un coll&egrave;gue.</P>
<P ALIGN="JUSTIFY">On peut regretter que nous n'ayons pas plus publi&eacute; sur le sujet (cf bibliographie) ; ce n'est pas faute d'y avoir &eacute;t&eacute; invit&eacute;, mais entre &eacute;crire du code et &eacute;crire du papier, nous n'h&eacute;sitions
 gu&egrave;re...</P>
<P ALIGN="JUSTIFY">Il me faut signaler pour terminer que cette saga n'aurait pu &ecirc;tre &eacute;crite sans la souplesse des structures de l'ESE, et la direction avis&eacute;e du Chef du Service Informatique, J. Hebenstreit. Qu'il en soit remerci&eacute;
 ici, ainsi que tous mes coll&egrave;gues non cit&eacute;s, mais qui forment la trame de ce service et avec lesquels les discussions ont souvent &eacute;t&eacute; fructueuses.</P>
<B><P ALIGN="JUSTIFY">Bibliographie</P><DIR>

</B><P ALIGN="JUSTIFY">-&#9;"Utilisation du Syst&egrave;me en Temps Partag&eacute; ESE (langage LSD)", Polycopi&eacute; n&#176; 2162, ESE, 1969,</P>
<P ALIGN="JUSTIFY">-&#9;"Un Langage Symbolique destin&eacute; &agrave; l'Enseignement : LSE", J. Hebenstreit, Y. Noyelle, Congr&egrave;s AFCET, Grenoble, Novembre 1972,</P>
<P ALIGN="JUSTIFY">-&#9;"LST : A Highly Adaptative Real-Time Time-Sharing System", S. Berche, J. Hebenstreit, Y. Noyelle, Symposium IFAC/IFIP, Tallinn, Mai 1976,</P>
<P ALIGN="JUSTIFY">-&#9;"Le LSE, son histoire, son d&eacute;veloppement", Y. Noyelle, &Eacute;ducation 2000 n&#176; 16, Institut Sup&eacute;rieur de P&eacute;dagogie, Paris, 1980,</P>
<P ALIGN="JUSTIFY">-&#9;"The Smalltalk Environment", Larry Tesler, BYTE, Ao&ucirc;t 1981,</P>
<P ALIGN="JUSTIFY">-&#9;Norme exp&eacute;rimentale Z65-020 : "LSE : Langage Symbolique d'Enseignement", AFNOR, Paris, D&eacute;cembre 1983,</P>
<P ALIGN="JUSTIFY">-&#9;"String Handling Facilities of the LSE language", Y. Noyelle, SIGPLAN, Ao&ucirc;t 1984,</P>
<P ALIGN="JUSTIFY">-&#9;"LSE83", J. Arsac, bulletin de l'EPI n&#176; 38, p. 116-139, Juin 1985.</P>
<P ALIGN="JUSTIFY"></P></DIR>
<HR>
<P>
<A HREF="yn.html"><IMG SRC="/pict/back.gif" ALIGN="MIDDLE"></A> Retour &agrave; la page d'accueil</P>
</FONT></BODY>
</HTML>
